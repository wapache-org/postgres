

# 调研PostgreSQL数组类型的支持情况



以下表为例

```sql
create table array_test(macs text[], collect_time timestamp);
```



## 数组的等值查询



```sql
select * from array_test where macs && array[ '1'];
```



## 数组字段的in查询

```sql
select * from array_test where macs && array[ '1','2','3'];
```



## 数组字段的like查询

```sql
SELECT *
FROM (
    SELECT unnest(macs) mac, *
    FROM array_test
) x
WHERE mac LIKE 'A%'
```

用到了`unnest`函数, [一行变多行的例子](https://blog.csdn.net/luojinbai/article/details/44458367)



## 数组字段建立索引和使用索引



### GIN索引

```sql
-- 数组类型内置支持GIN索引
CREATE INDEX idx_array_test_gin on array_test USING GIN (macs);

```

验证索引生效

```sql
-- 关闭全表扫描
SET enable_seqscan TO off;

-- 执行查询
EXPLAIN ANALYZE
SELECT * FROM array_test 
WHERE macs && ARRAY['123'] and collect_time between '${起始时间}' and '${截至时间}'
order by collect_time desc
;

-- 查询计划:
--   ->  Sort  (cost=10.26..10.27 rows=1 width=2934)
--          Sort Key: ((collect_time |=> '2000-01-01 00:00:00'::timestamp without time zone))
-- 
-- Bitmap Heap Scan on array_test  (cost=4.26..8.27 rows=1 width=32) (actual time=0.014..0.015 rows=2 loops=1)
-- Recheck Cond: (macs && ARRAY['123']::text[])
-- ->  Bitmap Index Scan on idx_array_test_gin  (cost=0.00..4.26 rows=1 width=0) (actual time=0.009..0.009 rows=2 loops=1)
--         Index Cond: (macs && ARRAY['123']::text[])
```

使用GIN索引, 不支持建立macs+collect_time的组合索引, 通过不通的配置参数, 只能按以下两种方式执行

1. 先通过macs过滤, 然后再通过collect_time过滤, 排序, 返回结果
2. 先通过collect_time过滤, 然后通过macs过滤, 排序, 返回结果

这两种方式都只能部分计划走索引, 剩下的步骤都只能把数据全部load到内存中做进一步的处理(就是查询计划中的`Bitmap Heap Scan`)



**当macs或collect_time单个字段的索引的过滤效果不理想时, 仍然会有比较大量的Heap Scan, 从而导致查询性能不高**

理论上, MAC地址的过滤效果应该是很不错的, 所以性能应该也可以接受的。



### BTREE_GIN索引

GIN索引不支持macs+collect_time的组合索引, 但是还有一个扩展支持, 就是`BTREE_GIN`索引

```sql
CREATE EXTENSION btree_gin;

CREATE INDEX idx_array_test_btree_gin ON array_test 
USING gin (tags, created_at);

EXPLAIN ANALYZE
SELECT * FROM gin_test 
WHERE tags && ARRAY['9040'] and created_at between '2021-01-23 05:44:34' and '2021-01-25 05:44:34'
order by created_at desc;

-- 默认会使用`Bitmap Heap Scan`, 如果想效率更高, 可以

set enable_bitmapscan = off;

-- 这样它就完全只走索引扫描了
```



### RUM索引

```sql

-- 通过安装扩展插件, 可以支持RUM索引
CREATE INDEX idx_array_test_rum ON array_test 
USING rum (macs rum_anyarray_addon_ops, collect_time) 
WITH (attach = 'collect_time', to = 'macs');

```



使用RUM索引, 可以解决GIN索引的弊端, 可以直接通过索引数据进行数据过滤和排序, 不需要读取多余的数据。以下是一个小例子

```sql
-- 关闭全表扫描
SET enable_seqscan TO off;

-- 执行查询
EXPLAIN ANALYZE
SELECT * FROM array_test 
WHERE macs && ARRAY['123'] and collect_time between '${起始时间}' and '${截至时间}'
order by collect_time desc
;

-- 查询计划举例
---------------------------------------------------------------------------------------
 Limit  (cost=4.00..12.01 rows=1 width=2934)
   ->  Index Scan using idx_array_test_rum on array_test (cost=4.00..12.01 rows=1 width=2934)
         Index Cond: (macs && ARRAY['123']::text[] and collect_time between '${起始时间}' and '${截至时间}')
         Order By: (collect_time |=> '2000-01-01 00:00:00'::timestamp without time zone)
(4 rows)
```

使用RUM索引, 支持建立macs+collect_time的组合索引, 可以直接通过索引查询返回查询结果, 效率极高。

 

**RUM索引需要额外安装, 目前已经测试PostgreSQL可以支持, Greenplum和Gauss未测试。**



## 补充说明



虽然可以通过`SET enable_seqscan TO off;`关闭全表扫描, 但是在一些未知的情况下, 好像还是会走全表扫描或者走collect_time的索引, 所以为了保证效率, 可以通过安装`pg_hint_plan`扩展插件来进一步保证查询计划是我们预期的。

```sql


select /**+ IndexScan(array_test) */ * from array_test where macs && array[ '1'];
select /**+ IndexScan(array_test idx_array_test_gin) */ * from array_test where macs && array[ '1'];
select /**+ IndexScan(array_test idx_array_test_rum) */ * from array_test where macs && array[ '1'];
```



## 安装数据库和扩展插件



通过代码安装试验失败, 目前通过CentOS的rpm方式安装部署:

```shell
yum update
yum install centos-release-scl
yum install llvm-toolset-7

yum install postgresql10 postgresql10-devel postgresql10-libs postgresql10-server postgresql10-contrib

# https://osdn.net/projects/pghintplan/releases/
rpm -ivh pg_hint_plan10-1.3.6-1.el7.x86_64.rpm

# 
rpm -ivh rum_10-1.3.7-1.rhel7.x86_64.rpm

#可选的初始化数据库时候自动启动
postgresql-10-setup initdb
systemctl enable postgresql-10
systemctl start postgresql-10

#登录
sudo -u postgres psql

select * from pg_available_extensions;

set enable_seqscan to off;


create extension rum;


create extension pg_hint_plan;
LOAD 'pg_hint_plan';
SET pg_hint_plan.enable_hint_tables TO on;

```



## 参考资料



https://github.com/postgrespro/rum

https://pghintplan.osdn.jp/pg_hint_plan.html

https://zh.osdn.net/projects/pghintplan/releases/

https://scm.osdn.net/gitroot/pghintplan/pg_hint_plan.git



























